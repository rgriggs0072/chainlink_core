import streamlit as st
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from utils.templates import email_templates

def get_mailjet_server():
    creds = st.secrets["mailjet"]
    server = smtplib.SMTP("in-v3.mailjet.com", 587)
    server.starttls()
    server.login(creds["API_KEY"], creds["SECRET_KEY"])
    return server


def send_reset_email(email: str, token: str, first_name: str = "User") -> dict:
    """
    Send a password reset email with a time-limited token.

    - Uses the deployed Streamlit base URL from st.secrets["app"]["base_url"].
    - Builds a reset link that hits the /reset_password route with ?token=...
    - Returns a dict with success + error info from the underlying SMTP send.
    """
    sender_email = "randy@chainlinkanalytics.com"

    app_base_url = st.secrets["app"]["base_url"].rstrip("/")
    reset_link = f"{app_base_url}/reset_password?token={token}"

    subject = "Chainlink Analytics Password Reset"
    html = email_templates.reset_password_template(first_name, reset_link)

    result = send_email(email, subject, html, sender_email)

    # Optional: in dev, show the reset link for sanity
    # st.write("DEBUG reset link:", reset_link, "email send result:", result)

    return result




def send_unlock_notification(email, first_name="User", unlocker_name="an admin"):
    sender_email = "randy@chainlinkanalytics.com"
    subject = "Your Chainlink Account Has Been Unlocked"
    html = email_templates.unlock_notification_template(first_name, unlocker_name)
    send_email(email, subject, html, sender_email)

def send_email(to_email: str, subject: str, html: str, from_email: str) -> dict:
    """
    Low-level Mailjet SMTP sender.

    Returns a dict with:
      - success: bool
      - error: str | None
    """
    msg = MIMEMultipart()
    msg["From"] = from_email
    msg["To"] = to_email
    msg["Subject"] = subject
    msg.attach(MIMEText(html, "html"))

    try:
        server = get_mailjet_server()
        server.send_message(msg)
        server.quit()

        # You could also st.write() in dev if you want visual confirmation.
        return {"success": True, "error": None}
    except Exception as e:
        # In production, keep the user-facing message generic and log the details.
        st.warning(f"⚠️ Failed to send email to {to_email}")
        st.exception(e)
        return {"success": False, "error": str(e)}

