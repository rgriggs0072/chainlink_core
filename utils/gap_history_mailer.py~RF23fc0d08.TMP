# utils/gap_history_emailer.py
"""
Gap History Emailer (PDF + summary)

Page overview for future devs:
- Sends Gap History PDFs (from GAP_CURRENT_STREAKS) to:
    - salesperson (TO)
    - manager (CC)
- Email body includes a short execution-style summary (like legacy HTML).
- The attachment is the Gap History PDF (per salesperson).

Hard rules:
- This module contains NO Streamlit UI.
- It does NOT publish snapshots or mutate data.
- It assumes snapshots are already published for the current week.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple

import pandas as pd

from utils.email_utils import send_email_with_attachment
from utils.pdf_reports import build_gap_streaks_pdf


# -----------------------------------------------------------------------------
# Data models
# -----------------------------------------------------------------------------
@dataclass
class Contact:
    salesperson_name: str
    salesperson_email: str
    manager_email: Optional[str] = None
    manager_name: Optional[str] = None


# -----------------------------------------------------------------------------
# Queries
# -----------------------------------------------------------------------------
def load_sales_contacts(con, tenant_id: int) -> pd.DataFrame:
    """
    Load active contacts.

    Returns columns:
      SALESPERSON_NAME, SALESPERSON_EMAIL, MANAGER_NAME, MANAGER_EMAIL
    """
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
              SALESPERSON_NAME,
              SALESPERSON_EMAIL,
              MANAGER_NAME,
              MANAGER_EMAIL
            FROM SALES_CONTACTS
            WHERE TENANT_ID = %s
              AND IS_ACTIVE = TRUE
            """,
            (tenant_id,),
        )
        rows = cur.fetchall()
        cols = [d[0] for d in cur.description]
    df = pd.DataFrame(rows, columns=cols) if rows else pd.DataFrame(columns=cols)
    if not df.empty:
        df["SALESPERSON_NAME_UPPER"] = df["SALESPERSON_NAME"].astype(str).str.strip().str.upper()
    return df


def fetch_current_streaks(
    con,
    tenant_id: int,
    chains: Optional[List[str]] = None,
    suppliers: Optional[List[str]] = None,
    salespeople: Optional[List[str]] = None,
    min_streak: int = 1,
) -> pd.DataFrame:
    """
    Fetch current streak rows from GAP_CURRENT_STREAKS, enriched with store address fields
    joined from CUSTOMERS.

    Notes:
    - GAP_CURRENT_STREAKS does NOT contain ADDRESS, so we join CUSTOMERS.
    - CUSTOMERS.TENANT_ID is VARCHAR, while streaks TENANT_ID is NUMBER -> cast streak tenant_id to VARCHAR.
    - We join on TENANT_ID + CHAIN_NAME + STORE_NUMBER (most reliable keys).
    """

    where_parts = ["s.TENANT_ID = %s", "s.STREAK_WEEKS >= %s"]
    params: List[object] = [int(tenant_id), int(min_streak)]

    def add_in(col: str, vals: Optional[List[str]]):
        vals = [v for v in (vals or []) if v]
        if not vals:
            return
        placeholders = ", ".join(["%s"] * len(vals))
        where_parts.append(f"{col} IN ({placeholders})")
        params.extend(vals)

    add_in("s.CHAIN_NAME", chains)
    add_in("s.SUPPLIER_NAME", suppliers)
    add_in("s.SALESPERSON_NAME", salespeople)

    sql = f"""
        WITH c_dedup AS (
            SELECT
                TENANT_ID,
                CHAIN_NAME,
                STORE_NUMBER,
                ADDRESS,
                CITY,
                COUNTY,
                ROW_NUMBER() OVER (
                    PARTITION BY TENANT_ID, CHAIN_NAME, STORE_NUMBER
                    ORDER BY COALESCE(UPDATED_AT, CREATED_AT) DESC
                ) AS rn
            FROM CUSTOMERS
            WHERE TENANT_ID = %s
        )
        SELECT
          s.TENANT_ID,
          s.SNAPSHOT_WEEK_START,
          s.FIRST_GAP_WEEK,
          s.LAST_GAP_WEEK,
          s.SALESPERSON_NAME,
          s.CHAIN_NAME,
          s.STORE_NUMBER,
          s.STORE_NAME,
          c.ADDRESS,
          c.CITY,
          c.COUNTY,
          s.UPC,
          s.PRODUCT_NAME,
          s.SUPPLIER_NAME,
          s.STREAK_WEEKS
        FROM GAP_CURRENT_STREAKS s
        LEFT JOIN c_dedup c
          ON c.TENANT_ID = TO_VARCHAR(s.TENANT_ID)
         AND c.CHAIN_NAME = s.CHAIN_NAME
         AND c.STORE_NUMBER = s.STORE_NUMBER
         AND c.rn = 1
        WHERE {" AND ".join(where_parts)}
        ORDER BY s.SALESPERSON_NAME, s.STREAK_WEEKS DESC, s.CHAIN_NAME, s.STORE_NUMBER, s.PRODUCT_NAME
    """

    # NOTE: we pass tenant_id twice: once for c_dedup WHERE, once in main WHERE parts
    params_with_cte = [str(tenant_id)] + params

    with con.cursor() as cur:
        cur.execute(sql, params_with_cte)
        rows = cur.fetchall()
        cols = [d[0] for d in cur.description]

    return pd.DataFrame(rows, columns=cols)



# -----------------------------------------------------------------------------
# Summary HTML (simple + actionable)
# -----------------------------------------------------------------------------
from datetime import datetime
import pandas as pd


def build_summary_html(salesperson_name: str, sp_df: pd.DataFrame, tenant_name: str = "") -> str:
    """
    Build a professional HTML email body for Gap History (PDF attachment).

    Notes for future devs:
    - Keep all styling inline / in <style> (email-client safe).
    - No external CSS or JS.
    - Assume some clients strip advanced CSS; tables are most reliable.
    """

    df = sp_df.copy()
    df["STREAK_WEEKS"] = pd.to_numeric(df.get("STREAK_WEEKS"), errors="coerce").fillna(1).astype(int)

    active_gaps = int(len(df))
    new_this_week = int((df["STREAK_WEEKS"] == 1).sum())
    two_three = int(df["STREAK_WEEKS"].isin([2, 3]).sum())
    four_plus = int((df["STREAK_WEEKS"] >= 4).sum())

    # Top chains / suppliers
    top_chains = (
        df["CHAIN_NAME"].fillna("Unknown")
        .value_counts()
        .head(3)
        .to_dict()
    )
    top_suppliers = (
        df["SUPPLIER_NAME"].fillna("Unknown")
        .value_counts()
        .head(3)
        .to_dict()
    )

    def _bullet_lines(d: dict) -> str:
        if not d:
            return "<div style='color:#666;'>None</div>"
        return "".join(
            f"<div style='margin:2px 0;'>• <b>{k}</b>: {v}</div>"
            for k, v in d.items()
        )

    generated = datetime.now().strftime("%Y-%m-%d %H:%M")

    # Light Chainlink-ish look without being fragile in email clients
    # (Tables + basic CSS)
    return f"""
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {{ margin:0; padding:0; background:#f6f8fb; }}
    .wrap {{ max-width:720px; margin:0 auto; padding:18px; font-family: Arial, Helvetica, sans-serif; color:#111; }}
    .card {{ background:#ffffff; border:1px solid #e6e9ef; border-radius:14px; overflow:hidden; }}
    .header {{ background:#6497D6; color:#fff; padding:16px 18px; }}
    .title {{ font-size:18px; font-weight:700; margin:0; }}
    .subtitle {{ font-size:13px; opacity:0.95; margin:6px 0 0; }}
    .content {{ padding:16px 18px 18px; }}
    .metrics {{ width:100%; border-collapse:separate; border-spacing:10px; }}
    .metric {{ background:#F8F2EB; border:1px solid rgba(0,0,0,0.06); border-radius:12px; padding:12px; }}
    .m_label {{ font-size:12px; color:#444; margin:0 0 6px; }}
    .m_val {{ font-size:20px; font-weight:700; margin:0; }}
    .section {{ margin-top:14px; }}
    .section h3 {{ font-size:14px; margin:0 0 8px; }}
    .note {{ background:#fff7e6; border:1px solid #ffe2a8; padding:10px 12px; border-radius:12px; font-size:13px; }}
    .footer {{ color:#777; font-size:12px; margin-top:14px; }}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <p class="title">Gap History – Weekly Focus</p>
        <p class="subtitle">{salesperson_name}{f" • {tenant_name}" if tenant_name else ""}</p>
      </div>

      <div class="content">
        <table class="metrics" role="presentation">
          <tr>
            <td class="metric" width="25%">
              <div class="m_label">Active gaps</div>
              <div class="m_val">{active_gaps}</div>
            </td>
            <td class="metric" width="25%">
              <div class="m_label">New this week</div>
              <div class="m_val">{new_this_week}</div>
            </td>
            <td class="metric" width="25%">
              <div class="m_label">2–3 weeks</div>
              <div class="m_val">{two_three}</div>
            </td>
            <td class="metric" width="25%">
              <div class="m_label">4+ weeks</div>
              <div class="m_val">{four_plus}</div>
            </td>
          </tr>
        </table>

        <div class="section">
          <h3>Top chains</h3>
          {_bullet_lines(top_chains)}
        </div>

        <div class="section">
          <h3>Top suppliers</h3>
          {_bullet_lines(top_suppliers)}
        </div>

        <div class="section note">
          <b>Attached:</b> your Gap History PDF.<br/>
          Priority order: <b>4+ weeks</b> → <b>2–3 weeks</b> → <b>new this week</b>.
        </div>

        <div class="footer">Generated {generated}</div>
      </div>
    </div>
  </div>
</body>
</html>
""".strip()



# -----------------------------------------------------------------------------
# Orchestrator
# -----------------------------------------------------------------------------
def send_gap_history_pdfs(
    con,
    tenant_id: int,
    tenant_name: str,
    sender_email: str,
    chains: Optional[List[str]] = None,
    suppliers: Optional[List[str]] = None,
    salespeople: Optional[List[str]] = None,
    min_streak: int = 1,
    only_salespeople: Optional[List[str]] = None,
) -> Dict[str, object]:
    """
    Send per-salesperson Gap History emails with PDF attachments.

    Returns:
      {
        "salesperson_success": int,
        "salesperson_fail": int,
        "skipped_salespeople": [str],
        "errors": [{"salesperson": str, "error": str}]
      }
    """

    # ------------------------------------------------------------------
    # Load contacts
    # ------------------------------------------------------------------
    contacts_df = load_sales_contacts(con, tenant_id)
    if contacts_df.empty:
        return {
            "salesperson_success": 0,
            "salesperson_fail": 0,
            "skipped_salespeople": ["(no SALES_CONTACTS rows)"],
            "errors": [],
        }

    contacts_df = contacts_df.copy()
    contacts_df["SALESPERSON_NAME_UPPER"] = (
        contacts_df["SALESPERSON_NAME"].astype(str).str.strip().str.upper()
    )

    contact_lookup = (
        contacts_df.drop_duplicates(subset=["SALESPERSON_NAME_UPPER"])
        .set_index("SALESPERSON_NAME_UPPER")
    )

    # ------------------------------------------------------------------
    # Load streaks
    # ------------------------------------------------------------------
    streaks_df = fetch_current_streaks(
        con=con,
        tenant_id=tenant_id,
        chains=chains,
        suppliers=suppliers,
        salespeople=salespeople,
        min_streak=min_streak,
    )

    if streaks_df.empty:
        return {
            "salesperson_success": 0,
            "salesperson_fail": 0,
            "skipped_salespeople": ["(no streak rows matched filters)"],
            "errors": [],
        }

    streaks_df = streaks_df.copy()
    streaks_df["SALESPERSON_NAME_UPPER"] = (
        streaks_df["SALESPERSON_NAME"].astype(str).str.strip().str.upper()
    )

    # Enforce "send selected only" if provided
    if only_salespeople:
        wanted = {str(x).strip().upper() for x in only_salespeople if x}
        streaks_df = streaks_df[streaks_df["SALESPERSON_NAME_UPPER"].isin(wanted)]

    # ------------------------------------------------------------------
    # Send loop
    # ------------------------------------------------------------------
    success = 0
    fail = 0
    skipped: List[str] = []
    errors: List[dict] = []

    for sp_key, sp_df in streaks_df.groupby("SALESPERSON_NAME_UPPER"):
        if not sp_key or sp_key not in contact_lookup.index:
            skipped.append(sp_key)
            continue

        contact = contact_lookup.loc[sp_key]
        salesperson_name = contact["SALESPERSON_NAME"]
        to_email = str(contact.get("SALESPERSON_EMAIL") or "").strip()
        cc_email = str(contact.get("MANAGER_EMAIL") or "").strip() or None

        if not to_email:
            skipped.append(salesperson_name)
            continue

        try:
            # ---------------------------
            # Build PDF
            # ---------------------------
            pdf_cols = [
                "CHAIN_NAME",
                "STORE_NUMBER",
                "STORE_NAME",
                "ADDRESS",
                "SUPPLIER_NAME",
                "PRODUCT_NAME",
                "UPC",
                "STREAK_WEEKS",
                "FIRST_GAP_WEEK",
                "LAST_GAP_WEEK",
            ]
            pdf_df = sp_df[[c for c in pdf_cols if c in sp_df.columns]].copy()
            pdf_bytes = build_gap_streaks_pdf(
            pdf_df,
            tenant_name=tenant_name,
            salesperson_name=salesperson_name,   # ✅ puts it in the header
             )

            # ---------------------------
            # Build email
            # ---------------------------
            html_body = build_summary_html(salesperson_name, sp_df, tenant_name=tenant_name)


            safe_name = salesperson_name.replace(" ", "_")
            subject = f"Gap History Report – {tenant_name}"
            filename = f"gap_history_{safe_name}.pdf"

            result = send_email_with_attachment(
                to_email=to_email,
                cc_email=cc_email,
                subject=subject,
                html=html_body,
                from_email=sender_email,
                attachment_bytes=pdf_bytes,
                attachment_filename=filename,
            )

            if result.get("success"):
                success += 1
            else:
                fail += 1
                errors.append(
                    {"salesperson": salesperson_name, "error": result.get("error")}
                )

        except Exception as e:
            fail += 1
            errors.append({"salesperson": salesperson_name, "error": str(e)})

    return {
        "salesperson_success": success,
        "salesperson_fail": fail,
        "skipped_salespeople": skipped,
        "errors": errors,
    }
