# ----------- reset_schedule_helpers.py -----------

import streamlit as st
import pandas as pd
import numpy as np
import openpyxl
import re
from datetime import datetime, date, time
from openpyxl.styles import NamedStyle
from sf_connector.service_connector import connect_to_tenant_snowflake
from openpyxl.utils import column_index_from_string, get_column_letter
from openpyxl import Workbook


def generate_reset_schedule_template() -> Workbook:
    """
    Build a blank Reset Schedule Excel template workbook.

    - Creates a sheet named 'RESET_SCHEDULE_TEMPLATE'
    - Writes the canonical headers in row 1
    - Leaves all data rows empty for the user to fill

    This is the official template for users to paste/enter reset schedule rows.
    """
    wb = Workbook()
    ws = wb.active
    ws.title = "RESET_SCHEDULE_TEMPLATE"

    headers = [
        "CHAIN_NAME",    # A
        "STORE_NUMBER",  # B
        "STORE_NAME",    # C
        "PHONE_NUMBER",  # D
        "CITY",          # E
        "ADDRESS",       # F
        "STATE",         # G
        "COUNTY",        # H
        "TEAM_LEAD",     # I
        "RESET_DATE",    # J
        "RESET_TIME",    # K
        "STATUS",        # L
        "NOTES",         # M
    ]

    for col_idx, header in enumerate(headers, start=1):
        ws.cell(row=1, column=col_idx, value=header)

    return wb

def format_reset_schedule(workbook):
    """
    Validates and formats a reset schedule workbook for upload.
    Ensures required fields are present, renames headers, and applies consistent formats.

    Returns:
        workbook (Workbook): Formatted openpyxl workbook object, or None if validation fails.
    """
    ws = workbook['RESET_SCHEDULE_TEMPLATE']

    # Validate and rename headers
    header_names = [
        'CHAIN_NAME', 'STORE_NUMBER', 'STORE_NAME', 'PHONE_NUMBER', 'CITY', 'ADDRESS',
        'STATE', 'COUNTY', 'TEAM_LEAD', 'RESET_DATE', 'RESET_TIME', 'STATUS', 'NOTES'
    ]
    for idx, header in enumerate(header_names, 1):
        ws.cell(row=1, column=idx, value=header)

    # Check for empty values in required columns
    
    # ------------------------------------------------------------------
    # Required columns: collect all row-level errors (with row numbers)
    # ------------------------------------------------------------------
    required_columns = {
        "B": "STORE_NUMBER",
        "C": "STORE_NAME",
        "J": "RESET_DATE",
        "K": "RESET_TIME",
    }

    errors: list[str] = []

    for col_letter, col_name in required_columns.items():
        col_idx = column_index_from_string(col_letter)

        # Start from row 2 (row 1 is header)
        for row_idx in range(2, ws.max_row + 1):
            cell = ws.cell(row=row_idx, column=col_idx)
            value = cell.value

            if value is None or (isinstance(value, str) and value.strip() == ""):
                errors.append(
                    f"Row {row_idx}: {col_name} (column {col_letter}) is required and cannot be blank."
                )

    # If any missing required values, hard stop and show all of them at once
    if errors:
        st.error("❌ Reset Schedule validation failed. Please fix the issues below and re-upload:")
        for msg in errors:
            st.markdown(f"- {msg}")
        return None


def upload_reset_data(df: pd.DataFrame, selected_chain: str):
    """
    Uploads reset schedule data to Snowflake after deleting existing entries for the selected chain.

    Args:
        df (pd.DataFrame): Formatted reset schedule data.
        selected_chain (str): Chain name to target for deletion + upload.
    """
    toml_info = st.session_state.get("toml_info")
    tenant_id = st.session_state.get("tenant_id")
    if not toml_info or not tenant_id:
        st.error("TOML or tenant ID missing from session state.")
        return

    conn = connect_to_tenant_snowflake(toml_info)
    selected_chain = selected_chain.upper()

    if df['CHAIN_NAME'].isnull().any() or df['STORE_NAME'].isnull().any():
        st.warning("CHAIN_NAME and STORE_NAME cannot be null. Please correct and try again.")
        return

    mismatches = df.loc[df['CHAIN_NAME'].str.upper() != selected_chain]
    if not mismatches.empty:
        st.warning(f"CHAIN_NAME mismatch: Found {len(mismatches)} rows not matching '{selected_chain}'.")
        return

    try:
        now = datetime.now()
        today = date.today()

        df['TENANT_ID'] = tenant_id

        # Convert to Snowflake-safe ISO strings (pyformat cannot bind Python datetime objects)
        df['CREATED_AT'] = now.strftime("%Y-%m-%d %H:%M:%S")
        df['UPDATED_AT'] = now.strftime("%Y-%m-%d %H:%M:%S")
        df['LAST_LOAD_DATE'] = today.strftime("%Y-%m-%d")

        # Normalize RESET_DATE → YYYY-MM-DD
        df['RESET_DATE'] = (
            pd.to_datetime(df['RESET_DATE'], errors='coerce')
              .dt.strftime("%Y-%m-%d")
        )

        # Normalize RESET_TIME → HH:MM:SS
        df['RESET_TIME'] = (
            pd.to_datetime(df['RESET_TIME'], errors='coerce')
              .dt.strftime("%H:%M:%S")
        )


        df.replace({np.nan: None, '': None}, inplace=True)

        expected_columns = [
            'CHAIN_NAME', 'STORE_NUMBER', 'STORE_NAME', 'PHONE_NUMBER', 'CITY', 'ADDRESS',
            'STATE', 'COUNTY', 'TEAM_LEAD', 'RESET_DATE', 'RESET_TIME', 'STATUS', 'NOTES',
            'TENANT_ID', 'CREATED_AT', 'UPDATED_AT', 'LAST_LOAD_DATE'
        ]

        df = df[expected_columns]

        placeholders = ', '.join(['%s'] * len(expected_columns))

        delete_query = f"DELETE FROM RESET_SCHEDULE WHERE CHAIN_NAME = '{selected_chain}'"
        insert_query = f"INSERT INTO RESET_SCHEDULE ({', '.join(expected_columns)}) VALUES ({placeholders})"

        with conn.cursor() as cur:
            cur.execute("BEGIN;")
            st.info(f"Removing existing RESET_SCHEDULE records for: {selected_chain}")
            cur.execute(delete_query)

            st.info("Inserting new records into RESET_SCHEDULE...")
            cur.executemany(insert_query, df.values.tolist())
            conn.commit()

        st.success(f"✅ Reset schedule uploaded for chain: {selected_chain}")

    except Exception as e:
        conn.rollback()
        st.error(f"❌ Upload failed: {e}")

    finally:
        conn.close()
