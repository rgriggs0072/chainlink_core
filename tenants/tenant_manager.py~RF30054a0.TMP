# ----------- tenants/tenant_management.py ------------------------

import streamlit as st
from cryptography.fernet import Fernet
from sf_connector.service_connector import get_service_account_connection

import binascii
import hashlib
import base64
import streamlit as st
from cryptography.fernet import Fernet, InvalidToken

def load_tenant_config(tenant_id):
    conn = get_service_account_connection()
    try:
        with conn.cursor() as cur:
            # --- 1) Fetch tenant TOML metadata ---
            cur.execute("""
                SELECT snowflake_user, account, warehouse, database, schema, tenant_name, logo_path, role
                FROM TENANTUSERDB.CHAINLINK_SCH.TOML
                WHERE TENANT_ID = %s
            """, (tenant_id,))
            row = cur.fetchone()
            if not row:
                st.error(f"No TOML config found for tenant_id {tenant_id}")
                return None

            # --- 2) Fetch Fernet-encrypted private key (stored as HEX of token) ---
            cur.execute("""
                SELECT PRIVATE_KEY_ENCRYPTED
                FROM TENANTUSERDB.CHAINLINK_SCH.SERVICE_KEYS
                WHERE TENANT_ID = %s
            """, (tenant_id,))
            encrypted_row = cur.fetchone()
            if not encrypted_row or not encrypted_row[0]:
                st.error(f"No private key found for tenant_id {tenant_id}")
                return None

            encrypted_key_raw = encrypted_row[0]  # expected HEX string of Fernet token

        # --- 3) Prepare bytes for Fernet.decrypt() ---
        # debug fingerprint of the stored value
        raw = encrypted_key_raw if isinstance(encrypted_key_raw, str) else str(encrypted_key_raw)
        raw_is_hex = all(c in "0123456789abcdefABCDEF" for c in raw) and (len(raw) % 2 == 0)

        print({
            "tenant_id": tenant_id,
            "raw_len": len(raw),
            "raw_prefix": raw[:16],
            "raw_is_hex": raw_is_hex,
        })

        try:
            if raw_is_hex:
                token = binascii.unhexlify(raw)  # bytes; should start with b"gAAAAA"
            else:
                # if someone ever switches the column to base64 or plain token, handle it gracefully
                if raw.startswith("gAAAAA"):              # plain token string
                    token = raw.encode("utf-8")
                else:                                      # try base64 token
                    token = base64.b64decode(raw)
        except Exception as e:
            print("unhexlify/base64 decode failed:", repr(e))
            st.error("❌ Failed to parse encrypted private key from SERVICE_KEYS.")
            return None

        # more debug (stable fingerprint of the token bytes)
        print({
            "token_sha1": hashlib.sha1(token).hexdigest().upper(),
            "token_prefix_bytes": token[:6],
            "token_len": len(token),
        })

        # --- 4) Decrypt with Fernet ---
        try:
            fernet_key_b64 = st.secrets["encryption"]["fernet_key"]
            fernet = Fernet(fernet_key_b64.encode("utf-8"))
            decrypted_pem = fernet.decrypt(token).decode("utf-8")
        except InvalidToken as e:
            st.error("❌ Failed to decrypt private key:")
            st.exception(e)
            return None
        except Exception as e:
            st.error("❌ Unexpected error while decrypting private key:")
            st.exception(e)
            return None

        # --- 5) Build tenant config ---
        tenant_config = {
            "tenant_id": tenant_id,
            "snowflake_user": row[0],
            "account":        row[1],
            "warehouse":      row[2],
            "database":       row[3],
            "schema":         row[4],
            "private_key":    decrypted_pem,
            "tenant_name":    row[5],
            "logo_path":      row[6],
            "role":           row[7],
        }

        print("🧩 tenant_config user:", tenant_config["snowflake_user"])

        return tenant_config

    finally:
        try:
            conn.close()
        except Exception:
            pass
